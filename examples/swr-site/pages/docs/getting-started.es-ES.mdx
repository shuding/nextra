import { Callout } from 'nextra/components'

# Comienza

## Instalaci칩n

Dentro del directorio de su proyecto React, ejecute lo siguiente:

```bash
yarn add swr
```

O con npm

```bash
npm install swr
```

## Inicio r치pido

Para APIs RESTFul normales con datos JSON, primero necesita crear una funci칩n
`fethcer`, que no es m치s que una envoltura del `fetch` nativo:

```jsx
const fetcher = (...args) => fetch(...args).then(res => res.json())
```

<Callout emoji="游눠">
  Si tu quieres usar API GraphQL o librer칤as como Axios, puedes crear tu propia
  funci칩n fetcher. Consulta [aqui](/docs/data-fetching) para ver m치s ejemplos.
</Callout>

Luego puede importar `useSWR` y empezar a usarlo dentro de cualquier componente
de la funci칩n:

```jsx
import useSWR from 'swr'

function Profile() {
  const { data, error } = useSWR('/api/user/123', fetcher)

  if (error) return <div>failed to load</div>
  if (!data) return <div>loading...</div>

  // renderizar datos
  return <div>hello {data.name}!</div>
}
```

Normalmente, hay 3 estados posibles de una solicitud: "loading", "ready", o
"error". Puedes utilizar el valor `data` y `error` para determinar el estadado
actual de la solicitud, y devolver la UI correspondiente.

## H치galo reutilizable

Cuando construye una aplicaci칩n web, es posible que haya que reutilizar los
datos en muchos lugares de la UI. Es incre칤blemente f치cil crear hooks de datos
reutilizables sobre SWR:

```jsx
function useUser(id) {
  const { data, error } = useSWR(`/api/user/${id}`, fetcher)

  return {
    user: data,
    isLoading: !error && !data,
    isError: error
  }
}
```

Y util칤celo en sus componentes:

```jsx
function Avatar({ id }) {
  const { user, isLoading, isError } = useUser(id)

  if (isLoading) return <Spinner />
  if (isError) return <Error />
  return <img src={user.avatar} />
}
```

Al adoptar este patr칩n, puede olvidarse del **fetching** de datos de forma
imperativa: inicie la solicitud, actualice el estado de carga, y devuelve el
resultado final. En cambio, su c칩digo es m치s declarativo: solo hay que
especificar qu칠 datos utiliza el componente.

## Ejemplo

En un ejemplo del mundo real, nuestro sitio web muestra una barra de navegaci칩n
y el contenido, ambos dependen del `user`:

import { Welcome } from '@components/diagrams/welcome'

<div className="mt-8">
  <Welcome />
</div>

Tradicionalmente, obtenemos los datos una vez utilizando `useEffect` en el
componente de nivel superiror, y pasarlo a los componentes hijos a trav칠s de
props (f칤jate que por ahora no manejamos el estado de error):

```jsx {7-11,17,18,27}
// componente de la p치gina

function Page() {
  const [user, setUser] = useState(null)

  // obtener datos
  useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => setUser(data))
  }, [])

  // estado de carga global
  if (!user) return <Spinner />

  return (
    <div>
      <Navbar user={user} />
      <Content user={user} />
    </div>
  )
}

// componentes hijos

function Navbar({ user }) {
  return (
    <div>
      ...
      <Avatar user={user} />
    </div>
  )
}

function Content({ user }) {
  return <h1>Welcome back, {user.name}</h1>
}

function Avatar({ user }) {
  return <img src={user.avatar} alt={user.name} />
}
```

Por lo general, necesitamos mantener todos los datos que se obtienen en el
componente de nivel superiror y a침adir las props a cada componente dentro del
치rbol. El c칩digo ser치 m치s dif칤cil de mantener si a침adimos m치s dependencia de
datos a la p치gina.

Aunque podamos evitar pasar props usando
[Context](https://reactjs.org/docs/context.html), sigue existiendo problema con
el contenido din치mico: Los componentes dentro del contenido de la p치gina pueden
ser din치micos, y componente de nivel superiror puede no saber qu칠 datos
necesitar치n sus componentes hijos.

SWR resuelve el problema perfectamente, Con el hook `useUser` que acabamos de
crear, el c칩digo puede ser refactorizado a:

```jsx {20,26}
// componente de la p치gina

function Page() {
  return (
    <div>
      <Navbar />
      <Content />
    </div>
  )
}

// componentes hijos

function Navbar() {
  return (
    <div>
      ...
      <Avatar />
    </div>
  )
}

function Content() {
  const { user, isLoading } = useUser()
  if (isLoading) return <Spinner />
  return <h1>Welcome back, {user.name}</h1>
}

function Avatar() {
  const { user, isLoading } = useUser()
  if (isLoading) return <Spinner />
  return <img src={user.avatar} alt={user.name} />
}
```

Los datos ahora estan vinculados a los componentes que los necesitan, y todos
los componentes son independientes entre s칤. Todo los componentes padre no
necesitan saber nada sobre los datos o el paso del mismo. S칩lo se renderizaran.
El c칩digo es mucho m치s sencillo y f치cil de mantener ahora.

Lo m치s bonito es que s칩lo se enviar치 **1 request** a la API, porque utilizan la
misma clave de SWR y la solicitud se **desduplica**, se almacena en **cach칠** y
se **comparte** autom치ticamente.

Tambi칠n, la aplicaci칩n tiene ahora la capacidad de volver a obtener los datos
cuando [el usuario se centra o se reconecta a la red!](/docs/revalidation) Esto
significa que, cuando el laptop del usuario se despierte de la suspeci칩n o
cambie de pesta침a del navegador, los datos se actualizar치n autom치ticamente.
